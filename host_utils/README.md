# Host side drivers, libraries, and test scripts

## Programming the FPGA

You can program the FPGA by the runtime/loadbit.sh script, and also get the list of devices and get their status either by target_index or the target ID:
```
./loadbit.sh list
./loadbit.sh prog RR_accel_1_8.bit --target_index=0
./loadbit.sh status --target "*06xx"
```

After programming the FPGA, a system reboot is required for the PCIe IP to properly be recognized.

* If there are multiple cards in a single machine, sometime the <ins>loadbit.sh</ins> script can only program the first card. In that situation you need to run Vivado to program the boards.

## Loading the driver

To build the driver, go to driver/mqnic and do

```make```

Then you can load the driver with

```sudo insmod mqnic.ko```

* If this operation fails, with errors such as ```mqnic: Unknown symbol ptp_clock_index (err 0)```, do ```modprobe ptp```

Now we need to reset the PCIe card to let the driver be properly loaded. To do so run the pcie_hot_reset.sh from runtime directory based on the device PCIe address, found in ```lspci``` output. For example:

```sudo ./pcie_hot_reset.sh 81:00.0```

If necessary to remove the driver, you can do so by:

```sudo rmmod mqnic.ko```

## Generating runtime binaries

There are 4 runtime binaries which all can be made by running ```make``` from the runtime directory. Their role are:
* rvfw: loads the firmware for RISCV codes, and configures the load balancer.
* perf: Reads back status of the system during runtime. Such as number of bytes and frames sent and received per RPU and interface, number of stalls, number of available slots, or some debug register values if they change from 0.
* dump: Similar to perf, but dumps to a file and runs for a limited time.
* pr_reload: Performs the steps to reload RPUs. Meaning puts each RPU into sleep, does the PR update process through Vivado, and reinitializes the RPU and boots it. The current binary is intended for our PR reload latency measurement experiment, and hence does reload of all RPUs for several iterations.

These binaries use the mqnic.c/h and rpu.c.h which are the developed host side libraries to access the Rosebud system through the Corundum driver, and the APIs to talk to RPUs and LB in Rosebud. Also timespec.c/h is used for the timing tests. For the PR reload, we use the mcap driver from Xilinx.

Note that rvfw overrides RPU memories with zero. To generate the zero blocks used for this purpose, go to <ins>Rosebud/riscv_code</ins> and run ```table_gen.py```. This script would generate files such as <ins>empty_dmem.bin</ins> and <ins>empty_pmem.bin</ins> if you got an error that they are missing.

## Makefile based experiments

To use Rosebud, binaries for RISC-V cores on the FPGA should be generated first. Then, they should be loaded to the cores, and also system setting such as receiving cores for the load balancer should be set. Finally, the host side profiling utility can be run to measure the throughput of the system. All these steps are performed from the ```make do``` rule in runtime directiry.

Different experiemnts can be run by changing the test firmware and setting the desired parameteres. You can pass these arguments to the ```make do``` rule:
* <ins>DEST_DIR</ins>: sets the directory to look for the RISC-V C file.
* <ins>TEST</ins>: Name of the main C file for the test.
* <ins>PKT_SIZE</ins>: Passes the packet size to the C file as a parameter.
* <ins>DEV</ins>: Sets the destination devices. If several FPGAs with Corundum interface are installed on the same machine, they can be addressed, e.g., <ins>mqnic0</ins> and <ins>mqnic1</ins>.
* <ins>ENABLE</ins>: Sets the active RPUs. This determines which RPUs get the firmware and load balancer considers them active. Can be used to disable some of the RPUs for the testing purposes.
* <ins>RECV</ins>: Sets the receiving RPUs in the load balancer. For instance, if we want to make a pipeline of two RPUs for each packet, we can set the first half of the RPUs to be receivers, which will receive the packets from the external interfaces, and then use the inter-core messaging to send the packets to the second half of the RPUs. Another example is if we want to use half of the cores to send data and half of them to receive data.
* <ins>DEBUG</ins>: Sets the debug register to look for. If a flag is raised within that debug register, from any RPU, the perf binary will print it. Used for debugging purposes.
* <ins>OUT_FILE</ins>: Sets the output for the accumulated results generated by the perf binary.

For instance, for the throughput test on a single machine with two Rosebud FPGAs we can run these in parallel:

```
make do TEST=pkt_gen RECV=0x0000 ENABLE=0xffff DEV=mqnic0 PKT_SIZE=1500
```

and

```
make do TEST=basic_fw RECV=0xffff ENABLE=0xffff DEV=mqnic1
```

It's better to first run the basic_fw so the FPGA is ready to receive the packets, and then start the pkt_gen.

If we want to see perfomance of 8 RPUs instead of 16 RPUs, we don't need to reload the FPGA with the 8RPU image, instead we can change the forwarder to do:

```
make do TEST=basic_fw RECV=0xaaaa ENABLE=0xaaaa DEV=mqnic1
```
where half of the RPUs are active.

If the firmware is already loaded, we can use ```make status``` which only runs the perf script according to the corresponding arguments. For the PR reload test, we can run ```make pr_test```. For reseting the FPGAs, the ```make reset``` rule resets all the FPGAs based on the vendor and device ID seen by the host system. ```make reset0``` is an example how to do the reset based on the PCIe bus address of the device.

We suggest to reset both boards before each data point test to minimize the result variance (through <ins>pcie\_hot\_reset.sh</ins> script described earlier).

## Run case studies

To run the code for case studies, use ```make do``` similar to the previous step, just instead of the <ins>basic_fw</ins> test we would use these commands:

```
make do TEST=firewall DEST_DIR=../../fpga_src/accel/ip_matcher/c/ RECV=0xffff ENABLE=0xffff DEV=mqnic1
```

which requires the image with the firewall accelerator. For the Pigasus case study, when loading the image with Hash load balancer do:

```
make do TEST=pigasus DEST_DIR=../../fpga_src/accel/pigasus_sme/c/ RECV=0xffff ENABLE=0xffff DEV=mqnic1
```

which uses software reordering in RISCV cores. For the HW reorder version, load the image with RR load balancer which resembles the impact of HW reorder and do:

```
make do TEST=pigasus2 DEST_DIR=../../fpga_src/accel/pigasus_sme/c/ RECV=0xffff ENABLE=0xffff DEV=mqnic1
```

## Latency test scripts

To measure the forwarding latency, we have to measure the latency once with loopback transceiver in the ports, and once by going from the packet generator FPGA to the forwarder FPGA and back, and compute the difference. In the latter case, for the forwarder FPGA we should run:
```make do TEST=basic\_fw RECV=0xaaaa ENABLE=0xffff DEV=mqnic1```.

The firmware for latency test uses half of the RPUs to generate the traffic, and half of them to receive the traffic. The generated traffic carries genearation timestamp, and the receiving RPU find the latency by deducting the generation timestap from the receive timestamp. Note that all the RPUs timestamps are synchronized. On the forwarder FPGA, we enable only half of the cores to be properly comparable and not underestimate the latency under high load.

For packet generation, run the run\_latency.sh bash script, and just change the <ins>out_dir</ins> variable between the two runs. Note that the <ins>dev</ins> should be set according to which FPGA is being used for the packet generation. This script would run the test for different packet sizes, and use tcpdump to capture the latency values sent by the RPUs.

Finally run <ins>latency_data_extractor.sh</ins> script for each of the output directories from the previous script. It will use the <ins>pcap\_parser.py</ins> Python script to extract the values reported by the RPUs from the pcaps. After this step, a unified file for the average values is generated pre experiment and across different packet sizes. The forwarding latency can be computed by deducting the values for each packet size.
